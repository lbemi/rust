fn main() {
    println!("Hello, world!");
}

/*
编译器会确保引用总是有效的。不安全 Rust 有两个被称为 裸指针（raw pointers）的类似于引用的新类型。和引用一样，
裸指针是不可变或可变的，分别写作 *const T 和 *mut T。这里的星号不是解引用运算符；它是类型名称的一部分。在裸指
针的上下文中，不可变 意味着指针解引用之后不能直接赋值。

裸指针与引用和智能指针的区别在于

允许忽略借用规则，可以同时拥有不可变和可变的指针，或多个指向相同位置的可变指针
不保证指向有效的内存
允许为空
不能实现任何自动清理功能
通过去掉 Rust 强加的保证，你可以放弃安全保证以换取性能或使用另一个语言或硬件接口的能力，此时 Rust 的保证并不适用。
*/
#[test]
//解引用裸指针
fn test_raw_pointers() {
    let mut num = 5;

    // 创建原始指针
    // 不可变
    let r1 = &num as *const i32;
    // 可变原始指针
    let r2 = &mut num as *mut i32;

    //可以在安全代码中创建裸指针，不过不能 解引用 裸指针和读取其指向的数据。
    //  现在我们要做的就是对裸指针使用解引用运算符 *，这需要一个 unsafe 块
    unsafe
    {
        println!("r1 is: {}", *r1);
        println!("r2 is: {}", *r2);
    }
    // 创建一个不能确定其有效性的裸指针
    let address = 0x012345usize;
    let r = address as *const i32;
}
